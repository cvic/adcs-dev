---
/**
    * Props
    * - accept: string of accepted MIME types/extensions (e.g. "image/*,.pdf")
    * - multiple: allow multiple files
    * - maxSizeMB: per-file size limit
    * - uploadUrl: optional server endpoint; if set, files will be uploaded via XHR with progress
    * - fieldName: multipart field name
    */

import { useTranslations, type Lang } from "@/i18n";
import { getRelativeLocaleUrl } from "astro:i18n";
const t = useTranslations(Astro.currentLocale as Lang);
const locale = Astro.currentLocale as Lang;

const {
    accept = "",
    multiple = true,
    maxSizeMB = 5,
    uploadUrl = "", 
    fieldName = "files",
    label = "Upload files",
} = Astro.props;
---

<style>
    .dropzone {
        border: 2px dashed var(--color-theme); /* slate-300 */
        border-radius: 1rem;
        padding: 1.25rem;
        text-align: center;
        cursor: pointer;
        transition: border-color .15s ease, background .15s ease;
    }
    .dropzone.focus, .dropzone.dragover { border-color: #2563eb; background: #f8fafc; } /* blue-600 / slate-50 */
    .hidden-input { display: none; }
    .file-list { margin-top: .75rem; display: grid; gap: .5rem; }
    .file-item {
        border: 1px solid #e5e7eb; border-radius: .75rem; padding: .5rem .75rem;
        display: grid; grid-template-columns: 48px 1fr auto; gap: .75rem; align-items: center;
    }
    .thumb { width: 48px; height: 48px; border-radius: .5rem; object-fit: cover; background:#f1f5f9; display:flex; align-items:center; justify-content:center; font-size:.75rem; }
    .meta { font-size: .9rem; }
    .name { font-weight: 600; word-break: break-word; }
    .size { color: #64748b; } /* slate-500 */
    .error { color: #b91c1c; font-size:.85rem; margin-top:.25rem; } /* red-700 */
    .progress-wrap { height: 6px; background:#f1f5f9; border-radius:9999px; overflow:hidden; margin-top:.4rem; }
    .progress { height: 100%; width: 0%; background:#2563eb; transition: width .15s linear; }
    button.reset { border:1px solid #e5e7eb; padding:.4rem .65rem; border-radius:.6rem; background:#fff; }
</style>




<div class=""> {t(
    {en: "Photos" ,
        ro: "Incarca poze"
    })}
    :
</div>
<div class="uploader">
    <div
            id="dropzone"
            class="dropzone"
            role="button"
            tabindex="0"
            aria-label={label}
    >
        <div><strong>{label}</strong></div>
        <div style="font-size:.9rem; color:#64748b; margin-top:.25rem;">
            Drag & drop files here, or click to choose
            {accept && ` (accepted: ${accept})`}
            {maxSizeMB && ` · max ${maxSizeMB}MB each`}
        </div>
        <input
                id="file-input"
                class="hidden-input"
                type="file"
                name={fieldName + (multiple ? "[]" : "")}
                {accept}
                {...(multiple ? { multiple: true } : {})}
        />
    </div>

    <div id="errors" class="error" aria-live="polite"></div>

    <div id="file-list" class="file-list" aria-live="polite"></div>

    <!--<div style="margin-top:.75rem; display:flex; ">-->
    <!--    <button type="button" id="btn-clear" class="reset">Clear</button>-->
    <!--</div>-->
</div>

<script type="module">
    const accept = {value: {accept: %s}, toString(){return this.value.accept}}
</script>
<script type="module">
    // Props from frontmatter (serialized safely)
    const PROPS = {
            accept: %s,
        multiple: %s,
        maxSizeMB: %s,
        uploadUrl: %s,
        fieldName: %s,
    };
</script>
<script is:inline>
    // Serialize props safely without exposing Astro internals
    (function(){
        const propsScriptTags = document.querySelectorAll('script[type="module"]');
        // The previous module script holds placeholders, we’ll rebuild a safe object here:
        window.__FILE_UPLOAD_PROPS__ = {
            accept: %s,
            multiple: %s,
            maxSizeMB: %s,
            uploadUrl: %s,
            fieldName: %s,
    };
    })();
</script>
<script type="module">
    // Minimal runtime (no frameworks)
    const props = window.__FILE_UPLOAD_PROPS__;
    const dz = document.getElementById('dropzone');
    const input = document.getElementById('file-input');
    const list = document.getElementById('file-list');
    const errors = document.getElementById('errors');
    const clearBtn = document.getElementById('btn-clear');

    const state = { files: [] }; // {file, url?, error?, progress?}

    function fmtBytes(bytes){
        const units = ['B','KB','MB','GB']; let i=0, n=bytes;
        while(n>=1024 && i<units.length-1){ n/=1024; i++; }
        return `${n.toFixed(n<10 && i>0 ? 1 : 0)} ${units[i]}`;
    }

    function validate(file){
        const max = props.maxSizeMB ? props.maxSizeMB*1024*1024 : Infinity;
        if (file.size > max) return `File too large (max ${props.maxSizeMB}MB)`;

        if (props.accept){
            const rules = props.accept.split(',').map(s => s.trim()).filter(Boolean);
            const ok = rules.some(rule => {
                if (rule.endsWith('/*')) {
                    const prefix = rule.replace('/*','');
                    return file.type.startsWith(prefix);
                }
                if (rule.startsWith('.')) {
                    return file.name.toLowerCase().endsWith(rule.toLowerCase());
                }
                // exact mime
                return file.type === rule;
            });
            if (!ok) return `File type not accepted`;
        }
        return null;
    }

    function render(){
        list.innerHTML = '';
        errors.textContent = '';
        state.files.forEach((item, idx) => {
            const row = document.createElement('div'); row.className = 'file-item';

            const thumb = document.createElement(item.url ? 'img' : 'div');
            thumb.className = 'thumb';
            if (item.url) { thumb.src = item.url; thumb.alt = item.file.name; }
            else { thumb.textContent = item.file.type.split('/')[0] || 'file'; }

            const meta = document.createElement('div'); meta.className = 'meta';
            const name = document.createElement('div'); name.className = 'name'; name.textContent = item.file.name;
            const size = document.createElement('div'); size.className = 'size'; size.textContent = fmtBytes(item.file.size);
            meta.appendChild(name); meta.appendChild(size);

            const right = document.createElement('div');
            right.style.display='grid'; right.style.gap='.25rem'; right.style.justifyItems='end';

            if (item.error){
                const err = document.createElement('div'); err.className='error'; err.textContent = item.error;
                meta.appendChild(err);
            } else {
                const barWrap = document.createElement('div'); barWrap.className='progress-wrap';
                const bar = document.createElement('div'); bar.className='progress';
                bar.style.width = (item.progress ?? 0) + '%';
                barWrap.appendChild(bar);
                meta.appendChild(barWrap);
            }

            const del = document.createElement('button'); del.type='button'; del.className='reset'; del.textContent='Remove';
            del.addEventListener('click', () => { removeAt(idx); });

            right.appendChild(del);

            row.appendChild(thumb);
            row.appendChild(meta);
            row.appendChild(right);
            list.appendChild(row);
        });
    }

    function removeAt(i){
        const [removed] = state.files.splice(i,1);
        if (removed?.url) URL.revokeObjectURL(removed.url);
        render();
        dispatch();
    }

    function dispatch(){
        const detail = { files: state.files.map(f => f.file) };
        const ev = new CustomEvent('fileschange',{ detail });
        dz.dispatchEvent(ev);
    }

    function addFiles(files){
        const arr = Array.from(files);
        for (const f of arr){
            const error = validate(f);
            const url = f.type.startsWith('image/') ? URL.createObjectURL(f) : null;
            state.files.push({ file: f, url, error, progress: error ? 0 : (props.uploadUrl ? 0 : 100) });
        }
        render();
        dispatch();
        if (props.uploadUrl) uploadAll();
    }

    function uploadAll(){
        // Upload files with no error and not yet uploaded
        state.files.forEach((item, idx) => {
            if (item.error || item.progress >= 100) return;

            const form = new FormData();
            form.append(props.fieldName || 'files', item.file);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', props.uploadUrl, true);

            xhr.upload.onprogress = (e) => {
                if (!e.lengthComputable) return;
                item.progress = Math.round((e.loaded / e.total) * 100);
                render();
            };

            xhr.onreadystatechange = () => {
                if (xhr.readyState === 4) {
                    if (xhr.status >= 200 && xhr.status < 300) {
                        item.progress = 100;
                    } else {
                        item.error = `Upload failed (${xhr.status})`;
                    }
                    render();
                }
            };

            xhr.onerror = () => { item.error = 'Network error'; render(); };
            xhr.send(form);
        });
    }

    // Drag & drop + click
    dz.addEventListener('click', () => input.click());
    dz.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); input.click(); }});
    dz.addEventListener('dragover', (e) => { e.preventDefault(); dz.classList.add('dragover'); });
    dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
    dz.addEventListener('drop', (e) => {
        e.preventDefault(); dz.classList.remove('dragover');
        if (e.dataTransfer?.files?.length) addFiles(e.dataTransfer.files);
    });
    input.addEventListener('change', (e) => {
        const files = e.currentTarget.files;
        if (files?.length) addFiles(files);
        // reset input to allow re-selecting same file
        e.currentTarget.value = '';
    });

    clearBtn.addEventListener('click', () => {
        state.files.forEach(f => f.url && URL.revokeObjectURL(f.url));
        state.files = []; render(); dispatch();
    });

    // announce ready
    render();
</script>
